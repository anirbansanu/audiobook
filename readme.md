Certainly! Here's the updated documentation with detailed explanations on how each method works.

---

# Text-to-Speech Converter Documentation

## Overview

The `TextToSpeechConverter` is a Python script that converts large text files into spoken audio using Google's Text-to-Speech (gTTS) API. The script processes the text file in chunks to handle large files efficiently, combines the generated audio chunks into a single MP3 file, and optionally plays the audio file.

## Features

- **Chunk Processing**: Handles large text files by processing them in smaller chunks.
- **Audio Concatenation**: Combines multiple audio chunks into a single MP3 file.
- **Automatic Cleanup**: Deletes temporary chunk files after processing.
- **Audio Playback**: Optionally plays the final audio file using the default media player.
- **Configurable Parameters**: Allows customization of language, output file name, and playback option.

## Requirements

- Python 3.x
- Required Python packages:
  - `gtts`
  - `pydub`
  - `tqdm`
- `ffmpeg` or `libav` for audio processing (necessary for `pydub`)

### Installation

1. **Install Python packages**:
   ```bash
   pip install gtts pydub tqdm
   ```

2. **Install `ffmpeg` (required for audio processing)**:
   ```bash
   sudo apt-get install ffmpeg
   ```

## Code Explanation

### Class Definition: `TextToSpeechConverter`

The `TextToSpeechConverter` class encapsulates the functionality for converting text to speech.

#### Initialization

```python
def __init__(self, file_path, lang='en', output_file='output.mp3', chunk_size=1024, play_audio=True):
```

- `file_path`: Path to the input text file.
- `lang`: Language code for speech synthesis (default: `'en'`).
- `output_file`: Name of the output MP3 file (default: `'output.mp3'`).
- `chunk_size`: Size of each text chunk to process (default: `1024` bytes).
- `play_audio`: Flag to control whether to play the audio after conversion (default: `True`).

**How it works**:
The constructor initializes the necessary parameters, creates a directory for storing audio chunks if it doesn't exist, and sets up the internal state for processing.

#### Methods

1. **`read_in_chunks(self, file_object)`**:
   
   ```python
   def read_in_chunks(self, file_object):
       """Lazy function (generator) to read a file piece by piece."""
       while True:
           data = file_object.read(self.chunk_size)
           if not data:
               break
           yield data
   ```

   **How it works**:
   - This method is a generator that reads the input text file in chunks of a specified size (`chunk_size`).
   - It yields each chunk of text, which allows for efficient processing of large files without loading the entire file into memory.

2. **`create_audio_chunks(self)`**:
   
   ```python
   def create_audio_chunks(self):
       with open(self.file_path, 'r') as file:
           total_size = os.path.getsize(self.file_path)
           with tqdm(total=total_size, unit='B', unit_scale=True, desc='Processing') as pbar:
               for i, chunk in enumerate(self.read_in_chunks(file)):
                   tts = gTTS(text=chunk, lang=self.lang)
                   chunk_file = f'audio_chunks/chunk_{i}.mp3'
                   tts.save(chunk_file)
                   self.chunk_files.append(chunk_file)
                   pbar.update(len(chunk))
                   print(f"Chunk {i} created: {chunk_file}")
   ```

   **How it works**:
   - Opens the input file and calculates its total size for the progress bar.
   - Iterates through the text chunks generated by `read_in_chunks`.
   - Uses `gTTS` to convert each chunk to speech and saves it as an MP3 file in the `audio_chunks` directory.
   - Updates the progress bar and prints a message indicating that the chunk has been created.

3. **`concatenate_audio_files(self)`**:
   
   ```python
   def concatenate_audio_files(self):
       combined = AudioSegment.empty()
       for file in self.chunk_files:
           audio = AudioSegment.from_mp3(file)
           combined += audio
       
       combined.export(self.output_file, format='mp3')
       print(f'Audio content written to file "{self.output_file}"')
   ```

   **How it works**:
   - Creates an empty `AudioSegment` object to store the combined audio.
   - Iterates through the list of chunk files, loads each MP3 file, and appends it to the combined audio segment.
   - Exports the combined audio to the specified output file.

4. **`clean_up_chunks(self)`**:
   
   ```python
   def clean_up_chunks(self):
       for chunk_file in self.chunk_files:
           os.remove(chunk_file)
   ```

   **How it works**:
   - Deletes each temporary audio chunk file from the `audio_chunks` directory to free up space.

5. **`play_audio_file(self)`**:
   
   ```python
   def play_audio_file(self):
       try:
           if os.name == 'posix':  # For Unix-like systems (Linux, MacOS)
               subprocess.run(["xdg-open", self.output_file])
           elif os.name == 'nt':  # For Windows
               subprocess.run(["start", self.output_file], shell=True)
           else:
               raise OSError("Unsupported operating system")
       except Exception as e:
           print(f"Error playing audio: {e}")
   ```

   **How it works**:
   - Attempts to play the final MP3 file using the system's default media player.
   - Uses different commands based on the operating system:
     - `xdg-open` for Unix-like systems (Linux, MacOS).
     - `start` for Windows.
   - Handles errors if the playback fails.

6. **`convert_text_to_speech(self)`**:
   
   ```python
   def convert_text_to_speech(self):
       self.create_audio_chunks()
       self.concatenate_audio_files()
       self.clean_up_chunks()
       if self.play_audio:
           self.play_audio_file()
   ```

   **How it works**:
   - Orchestrates the entire text-to-speech conversion process:
     - Calls `create_audio_chunks` to generate and save audio chunks.
     - Calls `concatenate_audio_files` to combine the chunks into a single MP3 file.
     - Calls `clean_up_chunks` to remove temporary files.
     - Optionally calls `play_audio_file` to play the final audio file based on the `play_audio` flag.

## Usage

### Command-line Interface

The script accepts command-line arguments to customize the text-to-speech conversion process.

```bash
python script.py <file_path> [--lang <lang>] [--output <output_file>] [--play]
```

- `<file_path>`: Path to the input text file (required).
- `--lang <lang>`: Language code (default: `'en'`).
- `--output <output_file>`: Name of the output MP3 file (default: `'output.mp3'`).
- `--play`: Flag to play the audio file after conversion (optional).

### Example

Convert a text file `input.txt` to speech in English and play the audio:

```bash
python script.py input.txt --lang en --output output.mp3 --play
```

### Configuration File (Optional)

You can use a configuration file to specify default settings for the conversion process.

**Configuration file (`config.ini`):**
```ini
[Settings]
lang = en
output = output.mp3
play = true
```

Run the script with the configuration file:

```bash
python script.py input.txt --config config.ini
```

## Troubleshooting

- **No Audio Playback**:
  - Ensure that `ffmpeg` or `libav` is installed on your system.
  - Verify that the default media player is set correctly on your system.

- **Errors While Generating Audio**:
  - Check that the input text file exists and is readable.
  - Ensure the language code is correct and supported by gTTS.



---

This documentation should provide a clear understanding of the `TextToSpeechConverter` code, including how it works internally and how to use it effectively.